"""The purpose of this function is to match the distribution of sectors measured in the experiment to the database generated by generateBeamspotDatabase.py to extract the beam spot for the experiment. This function takes as input a text file which continues the number of counts in each sector of the downstream detector (gated on the projectile PID). The counts should be ordered by sector number (1-32) and be listed in a single line. Values should be separated by commas, with no spaces."""
import numpy as np
import matplotlib.pyplot as plt
import sys

#Open the input file and the database
distributions = open(sys.argv[1],'r')
database = open("beamspotDatabase.txt",'r')

#Generate the sector distribution from the input file
sectorDist = distributions.readline()[:-1].split(",")
sectorDist = [int(x) for x in sectorDist]

totalCounts = sum(sectorDist)

residuals = np.zeros((41,41))
best_res = 9999
best_x = -999
best_y = -999

#Compute the variance of the data for calculating the chisq
variance = np.var(sectorDist)

#For each offset, we compute the residual between the simulated and experimental distributions, keeping track of which one is best
xIndex = 0
yIndex = 0
offsets = database.readline()[:-1].split(",")
while offsets != ['']:
  offsets = [float(x) for x in offsets]
  mcSectorDist = database.readline()[:-1].split(",")
  mcSectorDist = [totalCounts*float(x) for x in mcSectorDist]
  mcRingDist = database.readline()
  res = 0
  for j in range(32):
    res += (sectorDist[j] - mcSectorDist[j])**2/variance
  residuals[40-yIndex,xIndex] = res
  if(res < best_res):
    best_res = res
    best_x = offsets[0]
    best_y = offsets[1]
    best_dist = mcSectorDist
  yIndex += 1
  if yIndex > 40:
    xIndex += 1
    yIndex = 0
  offsets = database.readline()[:-1].split(",")

print(best_res,best_x,best_y)

#Plot the best fit, the chisq map, and the chisq map for results within one sigma of the best fit
figname = sys.argv[1].split("dist")[0] + "offsets.png"

dx, dy = 0.1, 0.1
x = np.arange(-2.05,2.10,dx)
y = np.arange(-2.05,2.10,dy)

extent = np.min(x), np.max(x), np.min(y), np.max(y)

plt.imshow(residuals, cmap='hot',interpolation='nearest',extent=extent)
plt.colorbar()
plt.xlabel("X offset (mm)")
plt.ylabel("Y offset (mm)")
plt.figtext(0.3,0.9,"Best Fit at (%4.3f,%4.3f)" % (10*best_x,10*best_y))
plt.scatter(best_x*10,best_y*10,c='w',marker='*')
plt.savefig(figname)
plt.close()

data_masked = np.ma.masked_where(residuals>best_res+2,residuals)

figname = sys.argv[1].split("dist")[0] + "offsets_twosigma.png"

plt.imshow(data_masked, cmap='hot',interpolation='nearest',extent=extent)
plt.colorbar()
plt.xlabel("X offset (mm)")
plt.ylabel("Y offset (mm)")
plt.figtext(0.3,0.9,"Best Fit at (%4.3f,%4.3f)" % (10*best_x,10*best_y))
plt.scatter(best_x*10,best_y*10,c='w',marker='*')
plt.savefig(figname)
plt.close()

figname = sys.argv[1].split("dist")[0] + "bestfit.png"

plt.plot(range(1,33),best_dist,c='r',label="Best Fit")
plt.plot(range(1,33),sectorDist,c='b',label="Measured")
plt.xlabel("Sector")
plt.ylabel("Counts")
plt.legend()
plt.savefig(figname)
plt.close()
